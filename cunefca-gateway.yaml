AWSTemplateFormatVersion: 2010-09-09
Description: |
  'Plantilla despliegue cloud gateway'
Parameters:
  appName:
    Description: 'Nombre de la aplicacion que se desplegara'
    Type: String
  appName2:
    Description: 'Nombre de la aplicacion que se desplegara'
    Type: String    
  Environment:
    Description: 'Nombre del ambiente'
    Type: String
  subNet1:
    Description: 'Subnet que se le asignara al servicio ecs'
    Type: String
  subNet2:
    Description: 'Subnet que se le asignara al servicio ecs'
    Type: String    
  VPCId:
    Description: 'Id de la VPC'
    Type: String
  apiGatewayStageName:
    Description: 'nombre del stage'
    Type: String

Resources:
  # Grupo de logs
  cloudwachGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join ["-", [cloudwatch, is, !Ref appName, !Ref Environment]]
  # Rol para el task definitions ecs
  ecsRole:
      Type: 'AWS::IAM::Role'
      Properties:
        RoleName: !Join [ "-", [ ecs, is, !Ref appName, policy, !Ref Environment]]
        AssumeRolePolicyDocument:
          Version: 2012-10-17
          Statement:
            - Action:
                - 'sts:AssumeRole'
              Effect: Allow
              Principal:
                Service:
                  - "ecs-tasks.amazonaws.com"
  # Politica para ecs
  ecsPolicy:
    Type: 'AWS::IAM::Policy'
    Properties:
      PolicyName: !Join [ "-", [ ecs, is, !Ref appName, policy, !Ref Environment] ]
      Roles:
        - !Ref ecsRole
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - 'logs:PutLogEvents'
              - 'logs:CreateLogStream'
              - 'logs:PutLogEvents'
            Effect: Allow
            Resource: '*'
              # - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group*'
          - Action:
              - 'ecr:BatchGetImage'
              - 'ecr:GetDownloadUrlForLayer'
              - 'ecr:BatchCheckLayerAvailability'
              - 'ecr:GetAuthorizationToken'
            Effect: Allow
            Resource: '*'
  # ecs Security Group          
  ecsSG:
      Type: AWS::EC2::SecurityGroup
      Properties:
        GroupName: !Join ["-",[is, securitygroup, !Ref appName, !Ref Environment]]
        GroupDescription: 'Enable Port communication'
        VpcId: !Ref VPCId
        SecurityGroupIngress:
          - IpProtocol: tcp
            FromPort: 8086
            ToPort: 8087
            CidrIp: 0.0.0.0/0 
  # ecs cluster
  ecsCluster:
    Type: 'AWS::ECS::Cluster'
    Properties:
      ClusterName: !Join [ "-", [ is, ecs, integration, service, !Ref appName, !Ref Environment ]]
      CapacityProviders:
        - FARGATE
      DefaultCapacityProviderStrategy:
        - CapacityProvider: FARGATE
          Weight: 1
  # task definition que se le asignara al servicio
  taskDefinition: 
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Join [ "-", [ is, task, !Ref appName, !Ref Environment ]]
      TaskRoleArn: !GetAtt ecsRole.Arn
      ExecutionRoleArn: !GetAtt ecsRole.Arn
      NetworkMode: 'awsvpc'
      Cpu: 512
      Memory: 1024
      RequiresCompatibilities:
        - 'FARGATE'
      ContainerDefinitions: 
        - Name: !Join ["-", [!Ref appName, !Ref Environment]]
          Image: !Sub '${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/nequi-cunefca-gateway-qa:stable'
          Essential: true
          HealthCheck:
            Command:
              - CMD-SHELL
              - curl -f http://localhost:8086/actuator/health
            StartPeriod: 150
          PortMappings:
            - ContainerPort: 8086
              HostPort: 8086
          logConfiguration:
            logDriver: awsfirelens
            options:
              Aws_Auth: On
              Aws_Region: us-east-1
              Host: vpc-apt0002-os-qa-co-01-4kuslqpzvvaljguiyyjoq7wb6a.us-east-1.es.amazonaws.com
              Index: ecs-cunefca-qa
              Name: es
              Port: '443'
              Type: doc
              tls: On
        - cpu: 0
          environment: []
          essential: true
          firelensConfiguration:
            type: fluentbit
          image: 906394416424.dkr.ecr.us-east-1.amazonaws.com/aws-for-fluent-bit:latest
          logConfiguration:
            logDriver: awslogs
            options:
              awslogs-group: cloudwatch-is-cunefca-gateway-qa
              awslogs-region: us-east-1
              awslogs-stream-prefix: ecs
          mountPoints: []
          name: log_router
                
  # servicio para el cluster            
  ecsService:
    Type: AWS::ECS::Service
    DependsOn:
      - LoadBalancerListenerHttp
    Properties:
      ServiceName: !Join ["-",[is, service, !Ref appName, !Ref Environment]]
      LoadBalancers:
        - ContainerName: !Join ["-", [!Ref appName, !Ref Environment]]
          ContainerPort: 8086
          TargetGroupArn: !Ref AlbTargetGroup
      Cluster: !Ref ecsCluster
      DesiredCount: 1
      LaunchType: 'FARGATE'
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - !Ref ecsSG
          Subnets:
            - !Ref subNet1
            - !Ref subNet2
      TaskDefinition: 
        !Ref taskDefinition

  taskDefinition2: 
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Join [ "-", [ is, task, !Ref appName2, !Ref Environment ]]
      TaskRoleArn: !GetAtt ecsRole.Arn
      ExecutionRoleArn: !GetAtt ecsRole.Arn
      NetworkMode: 'awsvpc'
      Cpu: 512
      Memory: 1024
      RequiresCompatibilities:
        - 'FARGATE'
      ContainerDefinitions: 
        - Name: !Join ["-", [!Ref appName2, !Ref Environment]]
          Image: !Sub '${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/nequi-cunefca-gateway-qa:latest'
          Essential: true
          HealthCheck:
            Command:
              - CMD-SHELL
              - curl -f http://localhost:8087/actuator/health
            StartPeriod: 150
          PortMappings:
            - ContainerPort: 8087
              HostPort: 8087
          logConfiguration:
            logDriver: awsfirelens
            options:
              Aws_Auth: On
              Aws_Region: us-east-1
              Host: vpc-apt0002-os-qa-co-01-4kuslqpzvvaljguiyyjoq7wb6a.us-east-1.es.amazonaws.com
              Index: ecs-cunefca-qa
              Name: es
              Port: '443'
              Type: doc
              tls: On
        - cpu: 0
          environment: []
          essential: true
          firelensConfiguration:
            type: fluentbit
          image: 906394416424.dkr.ecr.us-east-1.amazonaws.com/aws-for-fluent-bit:latest
          logConfiguration:
            logDriver: awslogs
            options:
              awslogs-group: cloudwatch-is-cunefca-gateway-qa
              awslogs-region: us-east-1
              awslogs-stream-prefix: ecs
          mountPoints: []
          name: log_router
                
  # servicio para el cluster            
  ecsService2:
    Type: AWS::ECS::Service
    DependsOn:
      - LoadBalancerListenerHttp2
    Properties:
      ServiceName: !Join ["-",[is, service, !Ref appName2, !Ref Environment]]
      LoadBalancers:
        - ContainerName: !Join ["-", [!Ref appName2, !Ref Environment]]
          ContainerPort: 8087
          TargetGroupArn: !Ref AlbTargetGroup2
      Cluster: !Ref ecsCluster
      DesiredCount: 1
      LaunchType: 'FARGATE'
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - !Ref ecsSG
          Subnets:
            - !Ref subNet1
            - !Ref subNet2
      TaskDefinition: 
        !Ref taskDefinition2

  AlbSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "external facing"
      VpcId: !Ref VPCId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 8086
          ToPort: 8087
          CidrIp: 0.0.0.0/0      
  # ALB http
  AplicationLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Type: application
      Name: !Join [ "-", [ is, alb, !Ref appName, !Ref Environment] ]
      Subnets:
        - !Ref subNet1
        - !Ref subNet2
      SecurityGroups: 
        - !Ref AlbSecurityGroup
      # configuracion de consumo interno (privado) con el valor "internal", consumo publico "internet-facing"  
      Scheme: internal

  LoadBalancerListenerHttp:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref AplicationLoadBalancer
      Port: 8086
      Protocol: HTTP
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref AlbTargetGroup

  LoadBalancerListenerHttp2:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref AplicationLoadBalancer
      Port: 8087
      Protocol: HTTP
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref AlbTargetGroup2

  AlbTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Join [ "-", [ is, alb-trg, !Ref appName, !Ref Environment]] 
      VpcId: !Ref VPCId
      Port: 8086
      Protocol: HTTP
      TargetType: ip
      UnhealthyThresholdCount: 2
      HealthCheckIntervalSeconds: 160
      HealthCheckPath: /actuator/health

  AlbTargetGroup2:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Join [ "-", [ is, trg, !Ref appName2, !Ref Environment]] 
      VpcId: !Ref VPCId
      Port: 8087
      Protocol: HTTP
      TargetType: ip
      UnhealthyThresholdCount: 2
      HealthCheckIntervalSeconds: 160
      HealthCheckPath: /actuator/health

  VpcLink:
    Type: 'AWS::ApiGatewayV2::VpcLink'
    Properties:
      Name: APIGWVpcLinkToPrivateHTTPEndpoint
      SubnetIds:
        - !Ref subNet1
        - !Ref subNet2
      SecurityGroupIds: [ ]
  # Create the API Gateway HTTP endpoint
  APIGWHTTPEndpoint:
    Type: 'AWS::ApiGatewayV2::Api'
    Properties:
      Name: serverlessland-pvt-endpoint
      ProtocolType: HTTP
  # Create the API Gateway HTTP_PROXY integration between the created API and the private load balancer via the VPC Link.
  # Ensure that the 'DependsOn' attribute has the VPC Link dependency.
  # This is to ensure that the VPC Link is created successfully before the integration and the API GW routes are created.
  APIGWHTTPEndpointIntegration:
    Type: 'AWS::ApiGatewayV2::Integration'
    Properties:
      ApiId: !Ref APIGWHTTPEndpoint
      IntegrationType: HTTP_PROXY
      ConnectionId: !Ref VpcLink
      ConnectionType: VPC_LINK
      IntegrationMethod: ANY
      IntegrationUri: !Ref LoadBalancerListenerHttp
      PayloadFormatVersion: '1.0'
    DependsOn:
      - VpcLink
      - APIGWHTTPEndpoint
      - LoadBalancerListenerHttp
  # API GW route with ANY method
  APIGWRoute:
    Type: 'AWS::ApiGatewayV2::Route'
    Properties:
      ApiId: !Ref APIGWHTTPEndpoint
      RouteKey: 'ANY /{proxy+}'
      Target: !Join
        - /
        - - integrations
          - !Ref APIGWHTTPEndpointIntegration
    DependsOn:
      - APIGWHTTPEndpointIntegration
  # Set a default stage
  APIStageDefault:
    Type: 'AWS::ApiGatewayV2::Stage'
    Properties:
      ApiId: !Ref APIGWHTTPEndpoint
      StageName: !Ref apiGatewayStageName
      AutoDeploy: true
    DependsOn:
      - APIGWHTTPEndpoint
  
  parserAutoScalingRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [application-autoscaling.amazonaws.com]
            Action: ["sts:AssumeRole"]
      Path: /
      Policies:
        - PolicyName: service-autoscaling
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action: ["application-autoscaling:*", "cloudwatch:DescribeAlarms", "cloudwatch:PutMetricAlarm",
                         "ecs:DescribeServices", "ecs:UpdateService"]
                Resource: "*"

  parserTarget:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Properties:
      MaxCapacity: 10
      MinCapacity: 1
      ResourceId: !Join ["/", [service, !Ref "ecsCluster", !GetAtt [ecsService, Name]]]
      RoleARN: !GetAtt [ parserAutoScalingRole, Arn ]
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs

  ScaleUp:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName: ParserPolicyUp
      PolicyType: StepScaling
      ScalingTargetId: !Ref parserTarget
      StepScalingPolicyConfiguration:
        Cooldown: 60
        MetricAggregationType: "Average"
        AdjustmentType: "ChangeInCapacity"
        StepAdjustments:
          - MetricIntervalLowerBound: 0
            MetricIntervalUpperBound: 5
            ScalingAdjustment: 1
          - MetricIntervalLowerBound: 5
            ScalingAdjustment: 2

  ScaleDown:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName: ParserPolicyDown
      PolicyType: StepScaling
      ScalingTargetId: !Ref parserTarget
      StepScalingPolicyConfiguration:
        Cooldown: 60
        MetricAggregationType: Average
        AdjustmentType: ChangeInCapacity
        StepAdjustments:
          - MetricIntervalUpperBound: -1
            MetricIntervalLowerBound: -5
            ScalingAdjustment: -1
          - MetricIntervalUpperBound: -5
            ScalingAdjustment: -2

  AutoScalingCPUAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: Scale-up if CPU > 90% for 10 minutes
      MetricName: CPUUtilization
      Namespace: AWS/ECS
      Statistic: Average
      Period: '300'
      EvaluationPeriods: '2'
      Threshold: '80'
      AlarmActions:
        - Ref: ScaleUp
        - Ref: ScaleDown
      OKActions:
        - Ref: ScaleUp
        - Ref: ScaleDown
      Dimensions:
        - Name: !Join [ "-", [ alarm, !Ref appName, !Ref Environment] ]
          Value:
            Fn::GetAtt:
              - ecsService
              - Name
        - Name: ClusterName
          Value:
            Ref: ecsCluster
      ComparisonOperator: GreaterThanThreshold

  parserTarget2:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Properties:
      MaxCapacity: 10
      MinCapacity: 1
      ResourceId: !Join ["/", [service, !Ref "ecsCluster", !GetAtt [ecsService2, Name]]]
      RoleARN: !GetAtt [ parserAutoScalingRole, Arn ]
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs

  ScaleUp2:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName: ParserPolicyUp
      PolicyType: StepScaling
      ScalingTargetId: !Ref parserTarget2
      StepScalingPolicyConfiguration:
        Cooldown: 60
        MetricAggregationType: "Average"
        AdjustmentType: "ChangeInCapacity"
        StepAdjustments:
          - MetricIntervalLowerBound: 0
            MetricIntervalUpperBound: 5
            ScalingAdjustment: 1
          - MetricIntervalLowerBound: 5
            ScalingAdjustment: 2

  ScaleDown2:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName: ParserPolicyDown
      PolicyType: StepScaling
      ScalingTargetId: !Ref parserTarget2
      StepScalingPolicyConfiguration:
        Cooldown: 60
        MetricAggregationType: Average
        AdjustmentType: ChangeInCapacity
        StepAdjustments:
          - MetricIntervalUpperBound: -1
            MetricIntervalLowerBound: -5
            ScalingAdjustment: -1
          - MetricIntervalUpperBound: -5
            ScalingAdjustment: -2

  AutoScalingCPUAlarm2:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: Scale-up if CPU > 90% for 10 minutes
      MetricName: CPUUtilization
      Namespace: AWS/ECS
      Statistic: Average
      Period: '300'
      EvaluationPeriods: '2'
      Threshold: '80'
      AlarmActions:
        - Ref: ScaleUp
        - Ref: ScaleDown
      OKActions:
        - Ref: ScaleUp
        - Ref: ScaleDown
      Dimensions:
        - Name: !Join [ "-", [ alarm, !Ref appName2, !Ref Environment] ]
          Value:
            Fn::GetAtt:
              - ecsService2
              - Name
        - Name: ClusterName
          Value:
            Ref: ecsCluster
      ComparisonOperator: GreaterThanThreshold
